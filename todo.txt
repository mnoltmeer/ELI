[+] признаком строки має бути " а не '

[+] нова директива #set #oldsym|#!oldsym визначає який стиль строкових констант
    використовувати 'old' чи "new"

[+] функція _DebugIntoFile() має робити вивід у зазначений файл

[x] при виявленні в рядку невідомої змінної виводяться два повідомлення про помилку замість одного
    це не обійти через те, що пошук змінної ведеться у числовому та символьному стеках

[x] сделать библиотеку для работы с потоками, чтобы определенный фрагмент кода
    выполнялся в отдельном потоке
    надто багато проблем тягне за собою

[+] доступ до об'єктів з користувацької аплікації

[+] сделать библиотеку по работе с объектами Stream
    (TFileStream, TMemoryStream, TStringStream)

[?] сделать бибилиотеку для работы с сущностями (Entity)
    Сущность - это транспортабельная единица данных, в которую могут входить
    одна или несколько переменных, объектов или процедур.
    Представляет собой два файла: бинарник с данными и описатель с кодом ELI

[x] добавить возможность запуска функций из dll (не оберток)
    ELI должен вызвать функцию с определенным набором параметров
    и вернуть результат в скрипт

[+] новая директива #protect{<некоторый код>}
    код скрипта в этой секции будет выполнен с гарантией от краха трансляции
    реализовать с помощью блоков try{}catch() с логированием исключения
    и продолжением трансляции

[+] переделать логирование, все логи (и трансляции и исключений)
    должны сохраняться в каталог пользователя ПК, чтобы избежать проблем с доступом

[+] добавить функцию _sleep(pMiliSec) которая приостанавливает трансляцию

[х] при використанні _return() трансляція відбувається успішно навіть за помилки у скрипті
    якщо у рядку перед _return() пропущено ";"
    схоже, цього не уникнути через властивості парсера

[х] надати можливість хост-аплікації створювати експортні змінні, які буде бачити ELI
    для цього є стек параметрів

[+] нова директива #trigger (<умова спрацювання>) {<певний код>}
    код у цій секції буде виконаний, якщо умова спрацювання буде істинною.
    Кожний рядок скрипту має перевірятись на істинність умов всіх зареєстрованих триггерів
    у код тригеру немає необхідності додавати директиву #protect, збій тригеру не
    впливає на трансляцію скрипту

[+] класам потрібні деструктори

[?] зробити клас, що описує BYTE* для передачі даних між потоками

[+] додати можливість з бібліотек відправляти повідомлення про помилки у лог ELI
    можливо варто додати функцію AddLogEvent() у інтерфейс

[x] перегрузити метод Create() щоб можна було запускати його без аргументів конструктора
    забагато логіки транслятора треба переробити

[+] не працює успадкування класів!

    #class A
    {
      #public method A($x){&$this.X = $x;}
      #public method Set($pos){&$this.X = $pos;}
      #property X = 0;
    }

    #class B : A
    {
      #public method B() {$Y = 4;}
    }

    якщо у класа В немає властивостей (і він не спадкує їх від А) то клас створюється
    некоректно - утворюється порожнє поле

    причина не зовсім зрозуміла: при отримані RESRECORDSET чомусь обнулялись поля
    на які посилався вказівник
    вирішено шляхом створення std::vector<RESOURCE> і копіювання даних спочатку туди

[+] зробити ф-ю ParseConstNums() яка будет парсити числові константи на манер
    ParseConstStrings() та підставляти замість них змінні

[+] нова директива #set {<директива>} - налаштовує інтерпретатор ELI

[+] #cnum | #!cnum, #csym | #!csym
    вмикають/вимикають парсинг символьних та числових констант

[+] #keepobjects|#!keepobjects
    вказує зберігати/не зберігати вміст стеку об'єктів після трансляції скрипту

[+] добитися, щоб методам об'єктів можна було передавати властивості/методи інших об'єктів
    майже готово, треба вирішити як бути, коли функції WorkWithObject() передається
    аргумент типу &obj.Set(30.000). Тоді через роздільник розрядів неправильно
    формується перелік аргументів для ф-ї RunMethod()

[+] доробити ParseConstNums(), треба вирішити як запобігти безкінечному парсингу
    індексів у змінних типу $CNUM[0], що підставляються замість констант

[+] директива #make має сама оголошувати змінну у яку зберігає фрагмент коду

[+] стек фрагментів росте з кожною трансляцією доки не звільниться бібліотека
    це відбувається тому що MarkFragments() за замовчуванням всі фрагменти
    позначає як глобальні, тому вони не видаляються зі стеку коли визивається FreeRes()
    треба визначитись, які фрагменти мають бути глобальними
    тепер за замовчуванням всі фрагменти - локальні, а глобальними їх робить
    (за потреби) алгоритм функції SearchAndMarkGlobalFragments()
