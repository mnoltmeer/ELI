[+] додати ф-ю для виводу вікна з повідомленням типу MessageBox()

[-] додати в налаштування інтерпретатора можливість встановлення локалі setlocale(LC_ALL, "")
    та кодової сторінки для виводу в консоль
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

[+] клонування властивостей, що містять вкладені об'єкти призводить до того
    що два об'єкта володіють одним вкладеним об'єктом
    так само при імпорті такої властивості
    вирішити, чи це баг, чи фіча
    фіча :)

[+] при імпорті властивості об'єкта, що містить клас, потрібно автоматично створювати вкладений об'єкт
    і додавати його до властивості об'єкта

[+] при імпорті властивості об'єкта, що є членом класу, імпортується значення з класу
    а треба брати значення з властивості об'єкта

[+] зависання ф-й друку та обчислення довжини строки у випадку якщо аргумент це символьне поле об'єкта
    тільки якщо поле це порожня строка ""
    прибрано перевірку на повертання порожньої строки від WorkWithObject() в ParseObjectsInExp()

[+] додати метод Clone(sym pSource) до стандартних методів об'єктів, що копіює всі властивості
    викликаючого об'єкта в об'єкт з ім'ям pTargetObjName

[-] пришвидшити роботу інтерпретатора з увімкненим логуванням

[+] _WriteOut() має додавати символ кінця строки

[+] переробити SaveELIState() та SaveVStState() для більш читабельного виводу інфи

[+] баг з безкінечним циклом в ExpFor() через наявність числової константи $CNUM[1]
    у параметрі кроку цикла
    виправлено через використання CalcExpNum() для визначення кроку

[+] проблема з успадкуванням методів, не спрацьовує вибірка зі стека процедур

[+] під час виклику конструктора виникає збій через те що у виклику конструктора
    &test.Create(C, ".\test.log") міститься константа
    а у виклику методу конструктора &test.C(.\test.log) - вміст константи
    що призводить до збою через крапку

    вирішується відміною розгортання змінних для ф-ї Create() у RunFunc()
    але тоді виникає проблема з викликом конструктора без аргументів
    або без описаного конструктора

    в RunFunc() ф-ю Create() додано у виключення на парсинг змінних
    а в RunProcedure() додано перевірку на те, що останній параметр це порожня строка

[+] під час виклику _DrawImage(&img.GetName()) де _DrawImage це ф-я із зовнішньої
    бібліотеки, метод eIface->GetCurrentFuncName() під час виконання _DrawImage
    повертає GetName замість _DrawImage
    виправлено рефакторингом методу RunFunc() і зміною логіки встановлення значення
    (current_func_name = fn_ptr->GetName())

[+] некоректно працює неймінг вкладених об'єктів через статичну змінну obname
    у CreateTempObject()
    вирішено скиданням значення obname = tmp перед виходом з функції
    щоб нівелювати зміни після рекурсії

[+] признаком строки має бути " а не '

[+] нова директива #set #oldsym|#!oldsym визначає який стиль строкових констант
    використовувати 'old' чи "new"

[+] функція _DebugIntoFile() має робити вивід у зазначений файл

[x] при виявленні в рядку невідомої змінної виводяться два повідомлення про помилку замість одного
    це не обійти через те, що пошук змінної ведеться у числовому та символьному стеках

[x] сделать библиотеку для работы с потоками, чтобы определенный фрагмент кода
    выполнялся в отдельном потоке
    надто багато проблем тягне за собою

[+] доступ до об'єктів з користувацької аплікації

[+] сделать библиотеку по работе с объектами Stream
    (TFileStream, TMemoryStream, TStringStream)

[?] сделать бибилиотеку для работы с сущностями (Entity)
    Сущность - это транспортабельная единица данных, в которую могут входить
    одна или несколько переменных, объектов или процедур.
    Представляет собой два файла: бинарник с данными и описатель с кодом ELI

[x] добавить возможность запуска функций из dll (не оберток)
    ELI должен вызвать функцию с определенным набором параметров
    и вернуть результат в скрипт

[+] новая директива #protect{<некоторый код>}
    код скрипта в этой секции будет выполнен с гарантией от краха трансляции
    реализовать с помощью блоков try{}catch() с логированием исключения
    и продолжением трансляции

[+] переделать логирование, все логи (и трансляции и исключений)
    должны сохраняться в каталог пользователя ПК, чтобы избежать проблем с доступом

[+] добавить функцию _sleep(pMiliSec) которая приостанавливает трансляцию

[х] при використанні _return() трансляція відбувається успішно навіть за помилки у скрипті
    якщо у рядку перед _return() пропущено ";"
    схоже, цього не уникнути через властивості парсера

[х] надати можливість хост-аплікації створювати експортні змінні, які буде бачити ELI
    для цього є стек параметрів

[+] нова директива #trigger (<умова спрацювання>) {<певний код>}
    код у цій секції буде виконаний, якщо умова спрацювання буде істинною.
    Кожний рядок скрипту має перевірятись на істинність умов всіх зареєстрованих триггерів
    у код тригеру немає необхідності додавати директиву #protect, збій тригеру не
    впливає на трансляцію скрипту

[+] класам потрібні деструктори

[?] зробити клас, що описує BYTE* для передачі даних між потоками

[+] додати можливість з бібліотек відправляти повідомлення про помилки у лог ELI
    можливо варто додати функцію AddLogEvent() у інтерфейс

[x] перегрузити метод Create() щоб можна було запускати його без аргументів конструктора
    забагато логіки транслятора треба переробити

[+] не працює успадкування класів!

    #class A
    {
      #public method A($x){&$this.X = $x;}
      #public method Set($pos){&$this.X = $pos;}
      #property X = 0;
    }

    #class B : A
    {
      #public method B() {$Y = 4;}
    }

    якщо у класа В немає властивостей (і він не спадкує їх від А) то клас створюється
    некоректно - утворюється порожнє поле

    причина не зовсім зрозуміла: при отримані RESRECORDSET чомусь обнулялись поля
    на які посилався вказівник
    вирішено шляхом створення std::vector<RESOURCE> і копіювання даних спочатку туди

[+] зробити ф-ю ParseConstNums() яка будет парсити числові константи на манер
    ParseConstStrings() та підставляти замість них змінні

[+] нова директива #set {<директива>} - налаштовує інтерпретатор ELI

[+] #cnum | #!cnum, #csym | #!csym
    вмикають/вимикають парсинг символьних та числових констант

[+] #keepobjects|#!keepobjects
    вказує зберігати/не зберігати вміст стеку об'єктів після трансляції скрипту

[+] добитися, щоб методам об'єктів можна було передавати властивості/методи інших об'єктів
    майже готово, треба вирішити як бути, коли функції WorkWithObject() передається
    аргумент типу &obj.Set(30.000). Тоді через роздільник розрядів неправильно
    формується перелік аргументів для ф-ї RunMethod()

[+] доробити ParseConstNums(), треба вирішити як запобігти безкінечному парсингу
    індексів у змінних типу $CNUM[0], що підставляються замість констант

[+] директива #make має сама оголошувати змінну у яку зберігає фрагмент коду

[+] стек фрагментів росте з кожною трансляцією доки не звільниться бібліотека
    це відбувається тому що MarkFragments() за замовчуванням всі фрагменти
    позначає як глобальні, тому вони не видаляються зі стеку коли визивається FreeRes()
    треба визначитись, які фрагменти мають бути глобальними
    тепер за замовчуванням всі фрагменти - локальні, а глобальними їх робить
    (за потреби) алгоритм функції SearchAndMarkGlobalFragments()
